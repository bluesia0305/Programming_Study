// 2022-05-24 수업


// 디지털화
// : 숫자, 문자, 색, 소리 등 모든 데이터를 bit state로 변환하는 과정
//   ex) 8비트 내에 7을 표현하면 00000111 (앞자리 빈 자리는 0으로 fill).

// 자료형(type)
// : 데이터를 저장하기 위해 특별한 규칙을 적용한 기능. 데이터의 종류, 저장 방식 등을 나타냄.
//   * 자료형의 종류: char, short, int, long, long long.
//   * unsigned: 부호가 없는 정수 = 즉 0과 자연수.
//   * signed: 부호가 있는 정수 -> 부호 비트를 사용하므로 1 Byte를 기준으로 생각해보면 실제 표현할 수 있는 자릿수는 1개 감소함.

// 변수(variable)
// : 자료형을 토대로 만든 데이터 공간이며, 식별자가 필요한 메모리 공간.

// 부호-절대값 표현법(Signed-magnitude representation)
// : 초기 프로그래머들은 음수를 표현하기 위해 최상위 비트(most significant bit, MSB)를
//   부호 비트로 사용하여 0으로 하면 양수, 1로 하면 음수로 사용하기로 하였음.
//   그러나 단순히 아래와 같은 방식으로 음수를 지정하면 문제가 발생함.
//   ex) 001 =  1
//       101 = -1
//   위의 두 수를 더하면 110 = -2가 됨 (원래는 합해서 0이 되어야 함).
//   이러한 문제(누산기의 법칙이 적용 불가능함)를 해결하기 위해 'N의 보수(complement)'를 도입함.

// N의 보수(N's complement)
// : 일반적으로 N진법에서 N-1의 보수, N의 보수는 다음을 의미함.
//   * N-1의 보수: 동일한 자릿수에서 자리 넘김을 하지 않는 가장 큰 수를 만들기 위해 필요한 보수.
//   * N의 보수: 현재 수보다 자리넘김을 한 자리 늘어난 수 중, 가장 작은 수를 만들기 위해서 필요한 보수. 일반적으로 (N-1의 보수) + 1.
//   즉, 이진법에서
//   1의 보수(one's complement) = 모든 자리수(digit)에 있는 0, 1을 반전.
//   2의 보수(two's complement) = 1의 보수 + 1.
//   N 비트 하에서 특정 수와 그 수의 2의 보수를 더하면 n+1 비트 1000...0 이 되는데 이때 가장 앞자리의 1은 n비트를 넘어가서 저장되지 않아 0이 됨.

// 정수 자료형 (signed) - LLP64 데이터 모델에서 각 자료형은 아래와 같은 표현 범위를 가짐.
// ---------------------------------------------------------------------------------------------------------
// 자료형				크기			표현 범위
// ---------------------------------------------------------------------------------------------------------
// signed char			1 Byte		-128 ~ +127
// signed short			2 Byte		-32,768 ~ +32,767
// signed int			4 Byte		약 -21억 (-2,147,483,648) ~ 21억(+2,147,483,647)
// signed long			4 Byte		약 -21억 (-2,147,483,648) ~ 21억(+2,147,483,647)
// signed long long		8 Byte		약 -922경 (-9,223,372,036,854,775,808) ~ 922경(+9,223,372,036,854,775,807)
// ---------------------------------------------------------------------------------------------------------
// unsigned char		1 Byte		0 ~ +255
// unsigned short		2 Byte		0 ~ +65,535
// unsigned int			4 Byte		0 ~ 약 42.9억 (+4,294,967,295)
// unsigned long		4 Byte		0 ~ 약 42.9억 (+4,294,967,295)
// unsigned long long	8 Byte		0 ~ 약 1,844경 (+18,446,744,073,709,551,616)
// ---------------------------------------------------------------------------------------------------------


#include <stdio.h>

int main()
{
	// 변수 선언 방법: 자료형 변수명;
	unsigned int hp;		  // 컴퓨터에게 "부호없는 정수를 저장할 형식인 hp라는 4 Byte 크기의 공간을 사용한다"고 선언.
	hp = 100;				  // "hp라는 이름의 공간에 100이라는 값을 초기화한다(initialize)"고 명령. 이때의 "="는 등호가 아닌 대입연산자.
	                          // 프로그래밍에서 공간에 값을 저장하는 것을 "초기화한다" 라고 표현함.

	printf("HP: %u\n", hp);   // 형식지정자(%): 특정 자료형(뒤에 오는 문자에 따라 다름)의 변수를 받아 해당 변수의 값을 불러오는 데 사용.
	
	// hp 변수에 새로운 값을 초기화한 뒤 재출력.
	hp = 200;
	printf("HP: %u\n", hp);

	// unsigned 자료형에 음수의 값을 입력하는 경우의 예시.
	// * 자료형에 따라 컴퓨터가 데이터를 읽어들이는 방식의 차이를 확인하기 위한 예시.
	hp = -1;
	printf("HP: %u\n", hp);   // %u: int형 변수의 공간의 값을 부호 없는 정수의 형태로 출력할 때 사용.

	// 아래와 같이 변수 선언과 동시에 초기화를 진행할 수 있음.
	signed char myChar = -10;

	printf("myChar: %d\n", myChar);   // %d: 정수 형태의 변수의 값을 받아 10진수로 출력할 때 사용.

	// 표현 범위를 초과하는 수를 변수의 값으로 초기화할 때의 예시.
	myChar = 128;
	printf("myChar: %d\n", myChar);   // 128 = 10000000(2) = 음수이면서 0000000 = 최소값 = 컴퓨터는 -128로 인식함.

	char myChar2;       // signed는 생략이 가능함(default).
	signed mySigned;    // 자료형을 생략하고 signed, unsigned만 이용하여 변수 선언이 가능함. 단, 이때는 int 자료형으로 자동적으로 지정됨.
	
	myChar2 = -100;
	mySigned = 100;
	printf("myChar2: %d\n", myChar2);
	printf("mySigned: %d\n", mySigned);

	return 0;
}