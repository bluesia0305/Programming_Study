// 2022-06-27 수업


// 동적할당(Dynamic allocation)
// : 런타임 도중에 사용자가 직접 공간을 할당받는 것을 말함.
//   동적할당한 공간은 사용자가 해제하지 않으면 프로그램이 종료할 때까지 남게 됨.

// Heap area
// : 사용자가 직접 관리하는 메모리 영역으로,
//   동적할당받은 메모리들이 저장되는 영역.


#include <iostream>

int main()
{
#pragma region Example
	// 지역변수에 할당된 메모리는 아래와 같이
	// 원하는 지점에서 선언 및 해제할 수 있으나 소스 코드가 복잡해짐.
	{
		int c = 3;
		{
			int d = 4;
			{
				int b = 2;
				int a = 1;
			}
		}
	}
#pragma endregion

	// 아래의 코드는 컴파일 상에서는 에러가 나지 않지만,
	// 프로그램 실행 도중, 할당받지 않은 공간에 접근하므로 런타임 에러가 발생함.
	//int arr[5];
	//for (int i = 0; i < 6; i++) arr[i] = 0;	- (Runtime) Error -

	// void* malloc(size)
	// : 해당 size 만큼의 Byte에 해당하는 메모리를 동적할당하며
	//   동적할당한 주소를 반환하는 함수.
	//   * void* : void pointer의 경우, 반환형을 모르며 주소값만을 저장함을 의미함.
	
	// C언어에서는 캐스팅 연산자 없이 선언이 가능하지만 (컴파일 상으로는 가능하나 원래는 오류임)
	// C++에서는 캐스팅 연산자를 반드시 이용하여 선언해야함.
	int* p = (int*) malloc(4);
	
	// 컴파일 상에서는 아래의 명령어가 NULL 포인터로 인식됨.
	// (malloc은 프로그램 실행 후 메모리를 할당시켜주므로 컴파일 상에서는 존재하지 않는 공간이므로 댕글링 포인터로 인식)
	*p = 10;
	printf("동적할당한 공간의 값: %i\n", *p);
	free(p);	// free( {address} ): 해당 주소값에 위치하는 동적할당받은 공간을 해제하는 명령어.
	p = NULL;	// 동적할당받은 공간을 해제한 뒤에는 댕글링 포인터가 만들어지지 않도록
				// 동적할당시에 사용했던 주소값을 0 (컴퓨터가 유일하게 사용하지 않는 주소)으로 초기화해야한다.

	// 보이드 포인터(Void pointer)
	// : 주소값이 가리키는 공간의 자료형을 알 수 없는 포인터로, 어떠한 주소값도 담을 수 있음.
	//   주소값이 가리키는 공간의 형식을 알 수 없으므로 역참조 연산이 실행되지 않음.
	void* voidPointer = malloc(4);
	//*voidPointer = 10;	- Error -
	

	// --- (주의) ---------------------------------------------------------
	// 동적할당한 공간을 모두 사용하였다면 반드시 해제해야 함.
	// 동적할당한 공간은 사용자가 직접 해제하지 않을 경우,
	// 프로그램이 끝날 때까지 유지가 되므로 메모리 누수가 발생한다.
	// 또한, 동적할당한 공간을 가리키기 위해 사용된 포인터는
	// 동적할당받은 공간의 해제 이후에는 댕글링 포인터로서 작용할 수 있기 때문에
	// 반드시 주소값을 0 (NULL)으로 초기해야 한다.
	// --------------------------------------------------------------------
	return 0;
}