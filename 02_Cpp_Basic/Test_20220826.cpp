/*
	< 시험 결과: 48점 >
	* 오답 문제: 22번(보기를 잘못 읽어서 틀림), 49번(그냥 틀림).

	1. Cpp 함수의 선언중 오류가 나타나는 것은 무엇인가 ?
	1 ) void  Func(auto param);
	2 ) void  Func(int* param = new int());
	3 ) void  Func((int*)param(int, int));
	4 ) void* Func(const int* const param);
	답 : 1
	(추가 공부)
	- 보기 3번: 함수 포인터 형태의 param을 매개변수로 사용하는 형태.
	- 보기 1번: 타입 추론형 자료형은 컴파일 타임에 값을 토대로 자료형이 결정되므로 매개변수로 사용 불가능.

	2. 함수의 오버로딩에 관한 설명중 올바르지 않는 것은 ? 
	1 ) 같은 이름의 함수지만 하는 작업이 다르게 정의하는 기능이다.
	2 ) 매개변수의 타입을 다르게 선언한다면 오버로딩이 가능하다.
	3 ) 매개변수의 자료형이 같더라도 개수가 다르다면 오버로딩이 가능하다.
	4 ) 반환형을 타입을 다르게 한다면 오버로딩이 가능하다.
	답 : 4

	3. 동적할당의 설명중 올바르지 않는 것은 ?
	1 ) new 연산자는 반환될 주소의 타입을 지정할 수 있다.
	2 ) 배열을 해제할 시 delete 를 사용한다.
	3 ) new 연산자는 생성자를 호출 한다.
	4 ) 동적할당한 배열을 해제할 시 delete 키워드를 작성하면 된다.
	답 : 2 (의도된 답안: 2번, 보기의 모호함으로 인해 4번도 복수 정답 처리)

	4. 참조자에 관한 설명중 올바르지 않은 것은 ?
	1 ) 참조자는 참조하고 있는 객체를 변경이 가능하다.
	2 ) 변수에 또 하나의 별칭을 지정해주는 기능이다.
	3 ) 선언과 동시에 초기화를 진행해야 한다.
	4 ) 변수의 주소를 저장하는 것이 아닌 공간 자체를 참조하는 기능이다. 
	답 : 1

	5. 다음과 같이 보기를 선언했을 때 같은 값끼리 짝지어진 것은 ?
	   int   Var     = 10;
	   int&  Ref     = Var;
	   int*  Pointer = &Var;
	   int*& pRef    = Pointer;

	1 ) &Var , &Ref , &Pointer, &pRef
	2 )  Var ,  Ref , *Pointer,  pRef 
	3 ) &Var , &Ref ,  Pointer, &pRef 
	4 ) &Var , &Ref ,  Pointer,  PRef
	답 : 4

	6. 접근제한자에 대한 설명으로 올바르지 않은 것은 ?
	1 ) class 와 같은 경우 접근제한자를 명시하지 않는다면 private 로 설정된다. 
	2 ) private 와 같은 경우 자기 자신을 제외한 어느 영역에서도 접근이 불가능하도록 막는 제한자이다.
	3 ) public 과 같은 경우 자기 자신뿐만이 아닌 어느 영역에서도 접근이 가능하도록 하는 제한자이다.
	4 ) protected 와 같은 경우 상속을 통한 객체라면 어느 영역에서도 접근이 가능하도록 하는 제한자이다.
	답 : 4 (의도된 답안: 4번, 보기의 모호함으로 인해 모두 정답 처리)
	(추가 공부)
	- friend 키워드나, 파생 클래스에서 접근제한자를 재설정하는 경우가 있으므로 답이 애매모호함.

	7. 생성자에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 생성자는 작성하지 않더라도 컴파일러가 기본 생성자를 제공해준다.
	2 ) 생성자는 오버로딩은 가능하지만 선택적 매개변수의 사용이 불가능하다.
	3 ) 생성자의 호출 시점은 객체를 선언했을 때 호출한다.
	4 ) 생성자를 작성한다면 컴파일러는 기본 생성자를 제공해주지 않는다.
	답 : 2

	8. 소멸자에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 오버로딩이 가능하다.
	2 ) ~클래스명() 으로 작성한다.
	3 ) 소멸자를 작성하지 않더라도 컴파일러가 기본 소멸자를 제공한다.
	4 ) 객체가 해제되는 시점에서 호출한다.
	답 : 1
	(추가 공부)
	- 소멸자는 매개변수를 사용할 수 없으므로, 오버로딩 또한 불가능하다.

	9. 복사생성자에 대한 설명으로 올바르지 않는 것은 ?
	1 ) 객체가 가지고 있는 맴버의 값을 복사해주는 생성자이다.
	2 ) 작성하지 않더라도 컴파일러가 제공한다.
	3 ) 매개변수의 타입은 포인터 상수가 사용된다.
	4 ) 같은 클래스로 이루어진 객체들만 복사가 가능하다.
	답 : 3

	10. 깊은 복사와 얕은 복사에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 얕은 복사는 맴버들의 값만을 복사하는 개념이다.
	2 ) 깊은 복사는 맴버들의 값만이 아닌 공간 자체를 복사하는 개념이다.
	3 ) 깊은 복사를 작성할 때 모든 공간에 대하여 복사를 하여야 한다.
	4 ) 얕은 복사는 값만을 복사하면 되기 때문에 대입연산만으로도 충분하다.
	답 : 3 (의도된 답안: 3번, 보기의 모호함으로 인해 모두 정답 처리)

	11. this pointer 에 대한 설명으로 옳은 것은 ?
	1 ) 설계도의 주소를 가리키는 포인터이다.
	2 ) 클래스 작성에서만 사용이 가능하다.
	3 ) 호출된 객체를 기준으로 컴파일러가 this 를 추가한다.
	4 ) this pointer 에는 delete 를 사용할 수 없다.
	답 : 3

	12. 객체들끼리 공유하는 맴버이지만 값의 변경이 불가능한 맴버는 무엇인가?
	1 ) 맴버 상수
	2 ) 정적 맴버
	3 ) this pointer
	4 ) 정적 맴버 상수
	답 : 4

	13. 특수한 개념을 묶어 프로그래밍하는 방법인 일반화를 적용시킨 C++ 의
	    프로그래밍 기법을 무엇이라 하는가 ?
	1 ) overload
	2 ) override
	3 ) template
	4 ) class
	답 : 3

	14. 객체지향의 4대 속성중 하나로 모델링 기법에 가장 적합한 속성은 무엇인가 ?
	1 ) 상속성
	2 ) 추상화
	3 ) 캡슐화
	4 ) 다형성
	답 : 2

	15. 객체 지향의 4대 속성중 하나로 Function Overload 와 Override 는 어떤 속성에 해당하는가?
	1 ) 상속성
	2 ) 추상화
	3 ) 캡슐화
	4 ) 다형성
	답 : 4

	16. 객체지향의 4대 속성중 하나로 접근제한자에 속성에 해당하는 것은 무엇인가 ?
	1 ) 추상화
	2 ) 상속성
	3 ) 다형성
	4 ) 캡슐화
	답 : 4

	17. 다음과 같이 기반 클래스를 상속 시켰을 때 기반 클래스의 맴버의 접근제한자
	    의 변경이 올바르게 짝지어진 것은 ?

		보기 ) class B : protected class A

		기반         파생
	1 ) public    -> private
		protected -> private
		private   -> private

	2 ) public    -> public
	    protected -> protected
		private   -> private

	3 ) public    -> protected
	    protected -> protected
		private   -> private

	4 ) public    -> protected
	    protected -> protected
		private   -> protected
	답 : 3
	(추가 공부)
	- 상속에서 기반 클래스 앞에 사용하는 접근제한자는 기반 클래스의 public 섹션 내의 멤버들에 대한 접근제한자를 지정한다.

	18. 다음과 같이 상속이 이루어져 있을 때 생성자와 소멸자의
	    호출 순서가 올바르게 짝지어진 것은 ?

		class A;
		class B : public class A;
		class C : public class B;
		
		생성자						소멸자
	1 ) A -> B -> C		  |		    A -> B -> C
	2 ) B -> C -> A		  |		    B -> C -> A
	3 ) A -> B -> C		  |		    C -> B -> A
	4 ) B -> C -> A		  |		    A -> B -> C
	답 : 3

	19. virtual 에 대한 설명으로 가장 올바른 것은 ?
	1 ) 파생 클래스에서 반드시 재정의를 해야하는 기능이다. 
	2 ) 객체를 참조하는 자료형을 기준으로 호출해주는 기능이다.
	3 ) 파생 클래스에서 재정의할 시 virtual 작성하지 않아도 가상함수가 된다.
	4 ) virtual 를 처음 사용한 메서드에 ovrride 작성이 가능하다.
	답 : 3 (의도된 답안: 3번, 보기 수정으로 인해 2번도 복수 정답 처리)

	20. Template class 의 상속으로 올바른 것은 ?
	1 ) template class 와 basic class 상속시 상속받은 템플릿을 정의를 생략해도 된다.
	2 ) template class 끼리의 상속시 자신의 템플릿과 부모의 템플릿을 모두 동시에 사용이 가능하다.
	3 ) template class 상속에서 사용할 부모 메서드는 템플릿을 정해주지 않아도 사용이 가능하다.
	4 ) template class 에서의 생성자 오버로딩은 불가능하다.
	답 : 2

	21. 가상 소멸자에 대한 설명으로 올바른 것은 ?
	1 ) 소멸자의 호출 순서가 기반에서 파생으로 끝나기 때문에 생겨난 개념이다.
	2 ) 소멸자 앞에 virtual 을 붙여 선언한다.
	3 ) 참조하고 있는 실제 객체를 기준으로 호출해주는 C 기본 함수 호출 방식 때문에 사용한다.
	4 ) 부모의 소멸자만 가상 소멸자로 지정해준다 해도 아무런 문제가 없다.
	답 : 2
	(추가 공부)
	- 보기 4번: 파생 클래스의 소멸자에 모두 virtual 키워드를 붙이지 않으면 가상 테이블 상에서 문제 발생할 수 있다.

	22. 순수 가상함수에 대한 설명으로 올바른 것은 ?
	1 ) 객체지향의 4대 속성중 상속성에 가장 가까운 기술이다.
	2 ) 함수뒤에 = 0;, pure , abstract 를 작성하여 선언한다.
	3 ) 순수가상함수를 하나 이상 가지고 있는 클래스를 인터페이스라고 한다.
	4 ) 파생 클래스에서 재정의하지 않을 시 해당 파생 클래스를 상속받은 파생 클래스에서 정의한다면 문제가 없다.
	답 : 2 (정답: 4)
	(추가 공부)
	- 보기 4번: 순수가상함수를 재정의하지 않은 파생 클래스(인터페이스)를 인스턴스화 시키지 않는다면 문제가 없다.
	
	23. Interface 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) __interface 를 작성하여 선언할 수 도 있다.
	2 ) 순수가상함수와 가상 소멸자만 가지고 있는 클래스를 의미한다.
	3 ) A is B 의 상속 기법을 따른 기능이다.
	4 ) 인터페이스의 이름은 보통 접두사 I 를 사용한다.
	답 : 3

	24. STL 의 구성요소로 알맞지 않은 것은 ?
	1 ) Algorithm
	2 ) Container
	3 ) ComInterface
	4 ) Allocator
	답 : 3

	25. 특정 단어를 가지고 어떠한 자료를 찾고 싶을 때 사용하기에
	    가장 적합한 것은 무엇인가 ?
    1 ) Queue
	2 ) Vector
	3 ) List
	4 ) Map
	답 : 4

	26. 시퀀스 컨테이너에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 선형적인 데이터 집합이다.
	2 ) 데이터의 삽입 / 제거가 빠르다.
	3 ) 요소의 탐색이 빠르다.
	4 ) FILO 형식을 띄고 있다.
	답 : 3

	27. 연관 컨테이너에 대한 설명으로 올바르지 않은 것은 ?
	1 ) Key 와 Value 를 쌍으로 가지고 있는 형태이다.
	2 ) 자료 탐색이 빠른 것이 장점이다.
	3 ) Set, Multi Map, map 등이 있다.
	4 ) 요소의 삽입 속도가 빠르다.
	답 : 4
	
	28. vector 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 시퀀스 컨테이너에 해당한다.
	2 ) 반복자 무효화 현상이 발생하는 경우가 있다.
	3 ) 배열과 유사한 구조를 띄고 있다.
	4 ) List 에 비해 요소의 삽입 / 제거가 매우 빠르다.
	답 : 4
	(추가 공부)
	- 보기 4번: 요소의 삽입/제거는 vector보다 list가 더 빠르다.

	29. vector 에서 사용할 수 있는 함수들의 설명으로 올바르지 않은 것은 ?
	1 ) empty : 요소가 비어있는 지 확인하는 함수로 비어있다면 false 요소가 하나라도 있다면 true 를 반환한다.
	2 ) push_back : vector 의 맨 뒤에 요소를 추가한다.
	3 ) pop : vector 의 맨 뒤에 요소를 제거한다.
	4 ) back : vector 의 맨 뒤의 요소를 반환한다.
	답 : 3 (의도된 답안: 1번, 보기가 잘못되어 3번도 복수 정답 처리)

	30. Iterator 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 컨테이너의 요소에 접근하기 위해 사용 된다.
	2 ) Iterator 와 같은 경우 컨테이너 같이 포함되는 개념이다.
	3 ) 요소를 순회할 때 ++, --, + , - 연산자를 사용한다.
	4 ) 요소의 위치를 저장하는 기능이다.
	답 : 2
	(추가 공부)
	- 보기 2번: iterator는 allocator에 포함되는 개념이다(객체를 저장하는 객체인 container의 개념이 아님).

	31. Map 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 연관 컨테이너에 포함된다.
	2 ) Key 와 Value 를 쌍으로 갖는 pair 형식을 저장한다.
	3 ) Key 의 중복을 허용한다.
	4 ) 요소의 탐색이 빠르다.
	답 : 3
	(추가 공부)
	- 보기 3번: key의 중복을 허용하는 map은 multimap이다.

	32. 다음중 상속된 형태의 캐스팅 방법으로 가장 적합한 것은 무엇인가 ?
	1 ) static_cast
	2 ) dynamic_cast
	3 ) reinterpret_cast
	4 ) const_cast
	답 : 2

	33. 포인터끼리의 형변환을 강제적으로 할 수 있는 하는 캐스팅 연산자는
	    무엇인가 ?
	1 ) static_cast
	2 ) dynamic_cast
	3 ) reinterpret_cast
	4 ) const_cast
	답 : 3

	34. Map 에서 사용가능한 함수들의 설명으로 올바르지 않은 것은 ?
	1 ) make_pair : pair 형식을 만들어 반환해주는 메서드이다.
	2 ) find : Key 를 갖는 요소를 찾고 찾았다면 true 아니라면 false 를 반환한다.
	3 ) erase : Key 를 갖는 요소를 찾아 제거한다.
	4 ) insert : 맵에 요소를 추가한다.
	답 : 2

	35. namespace 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 코드블럭의 공간에 이름을 정의하는 기능이다.
	2 ) namespace 사용이 반드시 이름을 정해줘야 한다.
	3 ) namespace 공간에 있는 요소들은 :: 연산자를 사용하여 접근한다.
	4 ) namespace 는 같은 이름의 namespace 를 사용이 불가능하다.
	답 : 2

	36. __cdcel 과 __stdcall 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 함수의 호출 규정 방식을 의미한다.
	2 ) __cdcel 은 가장 기본적인 함수의 호출 규정 방식이다.
	3 ) __stdcall 은 컴퓨터가 자동으로 호출하는 규정 방식이다.
	4 ) __cdcel 은 스택에 쌓은 파라미터를 함수 호출 내부에서 stack pointer 연산을 수행한다.
	답 : 4

	37. 연산자 오버로딩에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 기본 연산자의 기능 이외에 추가적인 기능을 부여하는 것이다.
	2 ) new 와 delete 는 오버로딩이 불가능하다.
	3 ) 작성시 operator 를 작성하여야 한다.
	4 ) 작성시 반환값과 매개변수 목록이 포함된다.
	답 : 2

	38. 해당 클래스로 인한 객체를 인스턴스화 시키고 싶지 않을 때의
	    방법으로 올바르지 않은 것은 ?
	1 ) 생성자를 public 이 아닌 protected 또는 private 로 선언한다.
	2 ) 순수 가상 함수를 포함 시킨다.
	3 ) 클래스 선언 시 abstarct 키워드를 작성한다. 
	4 ) 클래스 선언 시 final 키워드를 작성한다.
	답 : 4

	39. protected 형태로 선언한 생성자에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 해당 생성자를 통해 객체를 생성하지 못하도록 막는다.
	2 ) 상속 받은 파생 클래스에서만 해당 생성자로 인스턴스화 시키겠다는 것을 의미한다.
	3 ) 생성자 리스트를 통해서만 호출이 가능하다.
	4 ) 해당 클래스를 상속받은 클래스들은 모두 사용이 가능하다.
	답 : 3 (의도된 답안: 3번, 보기의 모호함으로 인해 1번도 복수 정답 처리)

	40. 다음 const 키워드의 의미가 알맞지 않은 것은 ?
	1 ) int * const       : 해당 공간을 상수화 시킨다.
	2 ) const int*        : 상수를 가리키는 포인터이다. 
	3 ) void Func() const : 해당 함수에서 맴버의 값 변경이 불가능하도록 막는다. 
	4 ) const int* Func() : 상수값인 주소를 반환하는 함수이다.
	답 : 4

	41. 다음 보기의 코드를 보고 마지막으로 출력되는 값은 무엇인가

	(보기)
	class A
	{
		protected :
			int a;
			int b;

		public :
			A() { a = b = 1; }

			int Get_a()
			{ return a; }

			virtual int Get_b()
			{ return b; }
	};

	class B : public A
	{
		int Get_a()
		{
			a += 10;
			return a; 
		}

		int Get_b()
		{
			b += 10;
			return b;
		}
	};

	int main()
	{
		A* a = new B();

		std::cout << a->Get_a() << a->Get_b();

		return 0;
	}

	1 ) 11
	2 ) 111
	3 ) 1110
	4 ) 1111
	답 : 2

	42. 다음의 코드는 오류를 발생하는데 오류를 수정하는 방법으로
	    올바른 것은 ?

	class A abstract
	{
		public : 
		virtual void PURE() = 0;
	};

	class B : public A
	{
		public :
		 int Member;

		public :
		 B() = default;
	};
	
	1 ) 클래스 선언시 작성한 abstract 키워드를 삭제한다.
	2 ) 클래스 A 에 생성자를 추가 한다.
	3 ) A 에 있는 함수를 제거한다.
	4 ) 상속받은 순수가상함수를 파생 클래스에서 재정의 한다.
	답 : 4

	43. 다음 보기의 코드중 올바르게 키워드가 작성되지 않은 곳은 ?

	(보기)
	class A final ...( 1 ) : public B 
	{
		public : 
		static int Member_1; 
		int static Member_2; ... ( 2 )

		public :
		A() const; ... ( 3 )

		inline const int* const Func(const int* const param) const; ... ( 4 )
	}
	답 : 3

	44. 다음중 타입 추론형에 해당하는 것은 무엇인가 ?
	1 ) decltype
	2 ) auto
	3 ) ref
	4 ) t_size
	답 : 2
	(추가 공부)
	- decltype(변수명): 이미 선언된 변수의 자료형과 동일하게 자료형을 설정해주는 기능.

	45. bool 에 대한 설명으로 올바르지 않는 것은 ?
	1 ) 0 , 1 를 저장 한다.
	2 ) true , false 를 저장한다.
	3 ) 100 을 저장할 수 있다.
	4 ) 2byte 를 차지한다.
	답 : 4

	46. window 좌표 구성에 대하여 올바르지 않은 것은 ?
	1 ) 좌상단 좌표계를 구성한다.
	2 ) Width , Height 는 모니터의 크기에 따라 달라진다.
	3 ) y 의 좌표가 커진다면 위치는 아래로 이동한다.
	4 ) x 의 좌표가 커진다면 위치는 오른쪽으로 이동한다.
	답 : 2

	47. 윈도우의 생성 과정이 올바르게 되어 있는 것은 ?
	1 ) winMain -> 창 생성 -> 창 클래스 등록 -> 메세지 루프
	2 ) winMain -> 창 클래스 등록 -> 창 생성 -> 메세지 루프
	3 ) winMain -> 메세지 루프 -> 창 클래스 등록 -> 창 생성
	4 ) winMain -> 창 클래스 등록 -> 메세지 루프 -> 창 생성
	답 : 2

	48. GetMessage 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) 주기적인 호출을 WM_TIMER 를 통하여 가능하다.
	2 ) 메세지가 없다면 하프타임이라는 while 문을 잠재우는 기능을 가진다.
	3 ) 메세지를 꺼내와 MSG 형식에 저장하는 기능을 가지고 있다.
	4 ) WM_DESTROY 메세지를 받는다면 false 를 반환한다. 
	답 : 4
	(추가 공부)
	- WM_QUIT: 프로그램 종료 시에 발생하는 메세지.
	- WM_DESTROY: 창을 종료할 때에 발생하는 메세지이며, 프로그램 종료와는 관계 없음.

	49. PeekMessage 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) CPU 연산을 통한 호출 주기가 매우 빠르다.
	2 ) 메세지를 꺼내와 MSG 형식에 저장하는 기능을 가지고 있다.
	3 ) GetMessage 와 같이 메세지를 꺼내오고 처리하는 과정이 필요없다. 
	3 ) 메세지가 없다면 false 를 반환한다.
	답 : 2 (정답: 3)
	(추가 공부)
	- 보기 2번: MSG msg 매개변수에 저장한다.
	- 보기 3번: GetMessage와 마찬가지로 메세지를 처리하는 과정이 필요하다(예시: DispatchMessage(), SendMessage() 등).

	50. MSG 에 대한 설명으로 올바르지 않은 것은 ?
	1 ) message 라는 맴버에 WM(Window Message) 형태를 저장한다.
	2 ) 마우스에 대한 추가적인 정보를 LPARAM 형태에 저장한다.
	3 ) 키보드 입력과 같은 추가적인 정보는 WPARAM 형태에 저장한다.
	4 ) HWND 형식을 저장하지는 않는다.
	답 : 4
*/