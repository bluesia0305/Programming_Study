// 2022-07-12 심화


#include <iostream>

// 운영체제
// : 32비트(x86) -> 주소값을 32 bit(= 4 byte)씩 끊어읽는다.
//   * 2^32 bit = 약 4 Gb의 메모리까지 할당 가능.
// 
//   64비트(x64) -> 주소값을 64 bit(= 8 byte)씩 끊어읽는다.
//   * 2^64 bit = 약 182 경 bit 의 메모리까지 할당 가능.


// 메모리 영역(Memory area)
// 1) Code 영역																			<낮은 주소(Low Memory)>
//    : 소스 코드, 이름공간, 함수, 전처리기, 제어문, 리터럴 상수 등을 저장하는 영역.
//
// 2) Data 영역
//    : 전역변수, 정적변수, 문자열 상수 등을 저장하는 영역.
// 
// 어플리케이션 실행 전부터 필요한 메모리 공간
// ------------------------------------------------------------------------------------------------------------
// 어플리케이션 실행 과정에서 필요한 메모리 공간
// 
// 3) Heap 영역
//    : 동적할당 공간에 대한 메모리 영역.
//    * Stack 영역에서보다 큰 자료형을 할당받는 것이 가능하다.
//    * 사용자가 원하는 시점에서 해제가 가능하다.
// 
// 4) Stack 영역
//    : 지역변수, 매개변수, 반환값 등을 저장하는 영역.
//    * 한 번에 할당받을 수 있는 공간의 크기가 작다.
//    * 간단한 코드로 메모리 관리를 할 수 있다(사용자가 직접 관리하지 않는다).				<높은 주소(High Memory)>
//
// -> Heap/Stack 영역으로 구분하여 메모리를 관리하는 이유는 결국 정해진 메모리를 효율적으로 사용하기 위함.


// 낮은 주소(low memory)		-> 주소값이 산술적인 의미로는 크다.
// : 운영체제를 위한 공간(kernel, 커널)이며, 다른 프로세스와 메모리를 공유하게 되는 공간.


// 높은 주소(High memory)	-> 주소값이 산술적인 의미로는 작다.
// : 어플리케이션을 위한 메모리 공간.
//   * Heap 영역(런타임에서 결정)과 Stack 영역(컴파일 타임에서 결정)은 서로 메모리 공간을 공유하는데,
//     Heap 영역에서 할당받은 메모리나 Stack 영역에서 할당받은 메모리가 너무 커져서
//     서로의 영역을 침범하는 것을 '오버플로우(overflow)'라고 한다.

int Global;					// 전역변수		-> Data 영역

void Function()				// 함수			-> Code 영역
{}

int main()
{
	int Local;				// 지역변수		-> Stack 영역
	int* p = new int();		// 동적할당 공간	-> Heap 영역
	
	printf("Address (Code area) : %p\n", Function);
	printf("Address (Data area) : %p\n", &Global);
	printf("Address (Heap area) : %p\n", p);
	printf("Address (Stack area): %p\n", &Local);
	
	delete p;
	p = nullptr;

	return 0;
}